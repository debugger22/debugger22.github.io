<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>Shortlog</title><link href="http://www.sudhanshumishra.in/" rel="alternate"></link><link href="http://www.sudhanshumishra.in/posts/feed/latest.atom" rel="self"></link><id>http://www.sudhanshumishra.in/</id><updated>2015-07-01T03:30:00+05:30</updated><entry><title>GSoC'15: Mixing both assumption systems, Midterm updates</title><link href="http://www.sudhanshumishra.in/posts/gsoc15-midterm-updates/" rel="alternate"></link><updated>2015-07-01T03:30:00+05:30</updated><author><name>Sudhanshu Mishra</name></author><id>tag:www.sudhanshumishra.in,2015-07-01:posts/gsoc15-midterm-updates/</id><summary type="html">&lt;p&gt;It's been very long since I've written anything here. Here's some of the pull requests that I've created during this period:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="https://github.com/sympy/sympy/pull/9490"&gt;Q.nonzero(non-real) now returns False&lt;/a&gt; Now &lt;code&gt;Q.nonzero&lt;/code&gt; requires the argument to be real along with nonzero to return &lt;code&gt;True&lt;/code&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="https://github.com/sympy/sympy/pull/9582"&gt;Make nonzero -&amp;gt; real &amp;amp; !zero like new assumptions&lt;/a&gt; This PR proposes the same change for old assumptions which has been mentioned earlier.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="https://github.com/sympy/sympy/pull/9583"&gt;An attempt to make zero an imaginary number&lt;/a&gt; To make both the systems consistent, this PR proposes to make &lt;code&gt;0&lt;/code&gt; an imaginary number in the old assumptions.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="https://github.com/sympy/sympy/pull/9562"&gt;Add few more facts to satask&lt;/a&gt; Now things like &lt;code&gt;satask(Q.negative(x + y), Q.positive(x) &amp;amp; Q.positive(y))&lt;/code&gt; work. The &lt;code&gt;known_facts&lt;/code&gt; was missing &lt;code&gt;Implies(Q.positive, ~Q.negative)&lt;/code&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="https://github.com/sympy/sympy/pull/9560"&gt;Proof of concept[1]: New assumptions check old assumptions for Symbol&lt;/a&gt; This PR enables new assumptions to read the assumptions set over &lt;code&gt;Symbol&lt;/code&gt; by changing the ask handlers.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="https://github.com/sympy/sympy/pull/9561"&gt;Proof of concept[2]: New assumptions check old assumptions for Symbol&lt;/a&gt; This PR enables new assumptions to read the assumptions set over &lt;code&gt;Symbol&lt;/code&gt; by changing the satask handlers.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;There's also this patch which makes changes in the &lt;code&gt;Symbol&lt;/code&gt; itself to make this work.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;commit de49998cc22c1873799539237d6202134a463956
Author: Sudhanshu Mishra &amp;lt;mrsud94@gmail.com&amp;gt;
Date:   Tue Jun 23 16:35:13 2015 +0530

    Symbol creation adds provided assumptions to global assumptions

&lt;span class="gh"&gt;diff --git a/sympy/core/symbol.py b/sympy/core/symbol.py&lt;/span&gt;
&lt;span class="gh"&gt;index 3945fa1..45be26d 100644&lt;/span&gt;
&lt;span class="gd"&gt;--- a/sympy/core/symbol.py&lt;/span&gt;
&lt;span class="gi"&gt;+++ b/sympy/core/symbol.py&lt;/span&gt;
&lt;span class="gu"&gt;@@ -96,8 +96,41 @@ def __new__(cls, name, **assumptions):&lt;/span&gt;
         False

         &amp;quot;&amp;quot;&amp;quot;
&lt;span class="gi"&gt;+        from sympy.assumptions.assume import global_assumptions&lt;/span&gt;
&lt;span class="gi"&gt;+        from sympy.assumptions.ask import Q&lt;/span&gt;
&lt;span class="gi"&gt;+&lt;/span&gt;
         cls._sanitize(assumptions, cls)
&lt;span class="gd"&gt;-        return Symbol.__xnew_cached_(cls, name, **assumptions)&lt;/span&gt;
&lt;span class="gi"&gt;+        sym = Symbol.__xnew_cached_(cls, name, **assumptions)&lt;/span&gt;
&lt;span class="gi"&gt;+&lt;/span&gt;
&lt;span class="gi"&gt;+        items_to_remove = []&lt;/span&gt;
&lt;span class="gi"&gt;+        # Remove previous assumptions on the symbol with same name.&lt;/span&gt;
&lt;span class="gi"&gt;+        # Note: This doesn&amp;#39;t check expressions e.g. Q.real(x) and&lt;/span&gt;
&lt;span class="gi"&gt;+        # Q.positive(x + 1) are not contradicting.&lt;/span&gt;
&lt;span class="gi"&gt;+        for assumption in global_assumptions:&lt;/span&gt;
&lt;span class="gi"&gt;+            if isinstance(assumption.arg, cls):&lt;/span&gt;
&lt;span class="gi"&gt;+                if str(assumption.arg) == name:&lt;/span&gt;
&lt;span class="gi"&gt;+                    items_to_remove.append(assumption)&lt;/span&gt;
&lt;span class="gi"&gt;+&lt;/span&gt;
&lt;span class="gi"&gt;+        for item in items_to_remove:&lt;/span&gt;
&lt;span class="gi"&gt;+            global_assumptions.remove(item)&lt;/span&gt;
&lt;span class="gi"&gt;+&lt;/span&gt;
&lt;span class="gi"&gt;+        for key, value in assumptions.items():&lt;/span&gt;
&lt;span class="gi"&gt;+            if not hasattr(Q, key):&lt;/span&gt;
&lt;span class="gi"&gt;+                continue&lt;/span&gt;
&lt;span class="gi"&gt;+            # Special case to handle commutative key as this is true&lt;/span&gt;
&lt;span class="gi"&gt;+            # by default&lt;/span&gt;
&lt;span class="gi"&gt;+            if key == &amp;#39;commutative&amp;#39;:&lt;/span&gt;
&lt;span class="gi"&gt;+                if not assumptions[key]:&lt;/span&gt;
&lt;span class="gi"&gt;+                    global_assumptions.add(~getattr(Q, key)(sym))&lt;/span&gt;
&lt;span class="gi"&gt;+                continue&lt;/span&gt;
&lt;span class="gi"&gt;+&lt;/span&gt;
&lt;span class="gi"&gt;+            if value:&lt;/span&gt;
&lt;span class="gi"&gt;+                global_assumptions.add(getattr(Q, key)(sym))&lt;/span&gt;
&lt;span class="gi"&gt;+            elif value is False:&lt;/span&gt;
&lt;span class="gi"&gt;+                global_assumptions.add(~getattr(Q, key)(sym))&lt;/span&gt;
&lt;span class="gi"&gt;+&lt;/span&gt;
&lt;span class="gi"&gt;+        return sym&lt;/span&gt;
&lt;span class="gi"&gt;+&lt;/span&gt;

     def __new_stage2__(cls, name, **assumptions):
         if not isinstance(name, string_types):


Master

In [1]: from sympy import *
In [2]: %time x = Symbol(&amp;#39;x&amp;#39;, positive=True, real=True, integer=True)
CPU times: user 233 µs, sys: 29 µs, total: 262 µs
Wall time: 231 µs


This branch

In [1]: from sympy import *
In [2]: %time x = Symbol(&amp;#39;x&amp;#39;, positive=True, real=True, integer=True)
CPU times: user 652 µs, sys: 42 µs, total: 694 µs
Wall time: 657 µs
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;I did a small benchmarking by creating 100 symbols and setting assumptions over them and then later asserting them. It turns out that the one with changes in the ask handers is performing better than the other two.&lt;/p&gt;
&lt;p&gt;Here's the report of the benchmarking:&lt;/p&gt;
&lt;h2&gt;When Symbol is modified&lt;/h2&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="gh"&gt;Line #    Mem usage    Increment   Line Contents&lt;/span&gt;
&lt;span class="gh"&gt;================================================&lt;/span&gt;
     6     30.2 MiB      0.0 MiB   @profile
     7                             def mem_test():
     8     30.5 MiB      0.3 MiB       _syms = [Symbol(&amp;#39;x_&amp;#39; + str(i), real=True, positive=True) for i in range(1, 101)]
     9     34.7 MiB      4.2 MiB       for i in _syms:
    10     34.7 MiB      0.0 MiB           assert ask(Q.positive(i)) is True
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;a href="https://www.dropbox.com/s/ndujng8drhouj4v/sym_mod.html?dl=0"&gt;pyinstrument report&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;When ask handlers are modified&lt;/h2&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="gh"&gt;Line #    Mem usage    Increment   Line Contents&lt;/span&gt;
&lt;span class="gh"&gt;================================================&lt;/span&gt;
     6     30.2 MiB      0.0 MiB   @profile
     7                             def mem_test():
     8     30.4 MiB      0.2 MiB       _syms = [Symbol(&amp;#39;x_&amp;#39; + str(i), real=True, positive=True) for i in range(1, 101)]
     9     31.5 MiB      1.1 MiB       for i in _syms:
    10     31.5 MiB      0.0 MiB           assert ask(Q.positive(i)) is True
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;a href="https://www.dropbox.com/s/6823wp6iob4zjg5/ask_mod.html?dl=0"&gt;pyinstrument report&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;When satask handlers are modified&lt;/h2&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="gh"&gt;Line #    Mem usage    Increment   Line Contents&lt;/span&gt;
&lt;span class="gh"&gt;================================================&lt;/span&gt;
     6     30.2 MiB      0.0 MiB   @profile
     7                             def mem_test():
     8     30.4 MiB      0.2 MiB       _syms = [Symbol(&amp;#39;x_&amp;#39; + str(i), real=True, positive=True) for i in range(1, 101)]
     9     41.1 MiB     10.7 MiB       for i in _syms:
    10     41.1 MiB      0.0 MiB           assert ask(Q.positive(i)) is True
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;a href="https://www.dropbox.com/s/l6a0037m6rxj84v/satask_mod.html?dl=0"&gt;pyinstrument report&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;On the other hand, the &lt;a href="https://github.com/sympy/sympy/pull/9475"&gt;documentation PR&lt;/a&gt; is almost ready to go.&lt;/p&gt;
&lt;p&gt;As of now I'm working on fixing the inconsistencies between the two assumption systems. After that I'll move to reduce autosimplification based on the assumptions in the core.&lt;/p&gt;
&lt;p&gt;That's all for now. Cheers!&lt;/p&gt;</summary><category term="python"></category><category term="sympy"></category><category term="gsoc"></category></entry><entry><title>GSoC'15: Week two</title><link href="http://www.sudhanshumishra.in/posts/gsoc15-week-two/" rel="alternate"></link><updated>2015-06-09T12:00:00+05:30</updated><author><name>Sudhanshu Mishra</name></author><id>tag:www.sudhanshumishra.in,2015-06-09:posts/gsoc15-week-two/</id><summary type="html">&lt;p align="center"&gt;
&lt;img src="http://www.sudhanshumishra.in/images/gsoc15.png" /&gt;
&lt;/p&gt;

&lt;p&gt;Second week of GSoC is over. I learned a lot this week about the assumptions system.&lt;/p&gt;
&lt;p&gt;Goal of this week was to finish the &lt;a href="https://github.com/sympy/sympy/pull/9475"&gt;documentation PR&lt;/a&gt; which I started few days back. I think it's complete now and ready for the final review.&lt;/p&gt;
&lt;p&gt;We also merged a very old and crucial &lt;a href="https://github.com/sympy/sympy/pull/2508"&gt;PR&lt;/a&gt; for the new assumptions started by Aaron. Now we really need to improve performance of &lt;code&gt;satask&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;This week I'll start working on adding assumptions on Symbols to global assumptions context.&lt;/p&gt;
&lt;p&gt;That's all for now. Cheers!&lt;/p&gt;</summary><category term="python"></category><category term="sympy"></category><category term="gsoc"></category></entry><entry><title>GSoC'15: Week one</title><link href="http://www.sudhanshumishra.in/posts/gsoc15-week-one/" rel="alternate"></link><updated>2015-06-05T23:00:00+05:30</updated><author><name>Sudhanshu Mishra</name></author><id>tag:www.sudhanshumishra.in,2015-06-05:posts/gsoc15-week-one/</id><summary type="html">&lt;p align="center"&gt;
&lt;img src="http://www.sudhanshumishra.in/images/gsoc15.png" /&gt;
&lt;/p&gt;

&lt;p&gt;The first week ended few days back. I managed to do few things during this period.&lt;/p&gt;
&lt;p&gt;I finished &lt;a href="https://github.com/sympy/sympy/pull/9228"&gt;#9228&lt;/a&gt; and got it merged into the master. I also started working on &lt;a href="https://github.com/sympy/sympy/pull/9475"&gt;documenting new assumptions&lt;/a&gt;. Thanks to Aaron for quick feedback on that.&lt;/p&gt;
&lt;p&gt;There are few hiccups in the latter one. After changing all predicate keys to &lt;code&gt;property&lt;/code&gt;, some of them started giving &lt;code&gt;None&lt;/code&gt; when used in &lt;code&gt;ask&lt;/code&gt;. I hope that I'll be able to sort it out before Monday.&lt;/p&gt;
&lt;p&gt;I'm also looking forward to merge &lt;a href="https://github.com/sympy/sympy/pull/2508"&gt;#2508&lt;/a&gt; this week. You are welcome to help me in reviewing this one.&lt;/p&gt;
&lt;p&gt;I'll start working on global assumptions once I'm done with the documentation.&lt;/p&gt;
&lt;p&gt;That's all for now. Cheers!&lt;/p&gt;</summary><category term="python"></category><category term="sympy"></category><category term="gsoc"></category></entry><entry><title>Google Summer of Code 2015 with SymPy</title><link href="http://www.sudhanshumishra.in/posts/gsoc15-with-sympy/" rel="alternate"></link><updated>2015-05-01T11:00:00+05:30</updated><author><name>Sudhanshu Mishra</name></author><id>tag:www.sudhanshumishra.in,2015-05-01:posts/gsoc15-with-sympy/</id><summary type="html">&lt;p align="center"&gt;
&lt;img src="http://www.sudhanshumishra.in/images/gsoc15.png" /&gt;
&lt;/p&gt;

&lt;p&gt;Once again I got accepted into Google Summer of Code! I'll be working on assumptions system of SymPy. This time, SymPy is participating under Python Software Foundation.&lt;/p&gt;
&lt;p align="center"&gt;
&lt;img src="http://www.sudhanshumishra.in/images/sympy.png" /&gt;
&lt;/p&gt;

&lt;p&gt;&lt;em&gt;SymPy is a Python library for symbolic mathematics. It aims to become a full-featured &lt;a href="https://en.wikipedia.org/wiki/Computer_algebra_system"&gt;Computer Algebra System&lt;/a&gt; while keeping the code as simple as possible in order to be comprehensible and easily extensible.&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;Here's what ideas page says about the project:&lt;/p&gt;
&lt;div style="border:1px solid #C74350;padding:10px;border-radius: 5px;"&gt;
&lt;i&gt;
The project is to completely remove our old assumptions system, replacing it
with the new one.&lt;br/&gt;&lt;br/&gt;

The difference between the two systems is outlined in the first two sections of this blog post.  A list of detailed issues can be found at this issue.&lt;br/&gt;&lt;br/&gt;

This project is challenging.  It requires deep understanding of the core of SymPy, basic logical inference, excellent code organization, and attention to performance.  It is also very important and of high value to the SymPy community.&lt;br/&gt;&lt;br/&gt;

You should take a look at the work started at
&lt;a href="https://github.com/sympy/sympy/pull/2508"&gt;https://github.com/sympy/sympy/pull/2508&lt;/a&gt;. Numerous related tasks are mentioned in the "Ideas" section.
&lt;/i&gt;
&lt;/div&gt;

&lt;p&gt;My mentors are &lt;a href="https://github.com/asmeurer"&gt;Aaron Meurer&lt;/a&gt; and &lt;a href="https://github.com/tjl"&gt;Tim Lahey&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Currently SymPy has two versions of mathematical assumptions. One is called "old assumptions" because a new implementation has been carried out recently. Since "old assumptions" were developed a long back, they are more mature and faster. However, because of its design, it is not capable of doing some interesting things like assuming something over an expression e.g. &lt;code&gt;x**2 + 2 &amp;gt; 0&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Old assumptions store assumptions in the object itself. For example, the code &lt;code&gt;x = Symbol('x', finite=True)&lt;/code&gt; will store the assumption that the &lt;code&gt;x&lt;/code&gt; is finite in this object itself.&lt;/p&gt;
&lt;p&gt;Both systems expose different APIs to query the facts:&lt;/p&gt;
&lt;p&gt;Old:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;In&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;]:&lt;/span&gt; &lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;sympy&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;

&lt;span class="n"&gt;In&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;]:&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;Symbol&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;x&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;imaginary&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="bp"&gt;True&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="n"&gt;In&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;]:&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;is_real&lt;/span&gt;
&lt;span class="n"&gt;Out&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;]:&lt;/span&gt; &lt;span class="bp"&gt;False&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;New:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;In&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;]:&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;Symbol&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;y&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="n"&gt;In&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;]:&lt;/span&gt; &lt;span class="n"&gt;ask&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Q&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;real&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="n"&gt;Q&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;positive&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;span class="n"&gt;Out&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;]:&lt;/span&gt; &lt;span class="bp"&gt;True&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;My work includes but is not limited to:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Identifying inconsistencies between old and new assumptions and eliminate them.&lt;/li&gt;
&lt;li&gt;Improving performance of the new assumptions.&lt;/li&gt;
&lt;li&gt;Making new assumptions read old assumptions.&lt;/li&gt;
&lt;li&gt;Removing assumptions from the core as much as possible.&lt;/li&gt;
&lt;li&gt;Making API of old assumptions call new assumptions internally.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;That's all for now. Looking forward to a great summer!&lt;/p&gt;</summary><category term="python"></category><category term="sympy"></category><category term="gsoc"></category></entry></feed>