<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>Shortlog</title><link href="http://www.sudhanshumishra.in/" rel="alternate"></link><link href="http://www.sudhanshumishra.in/feeds/cloud.tag.atom.xml" rel="self"></link><id>http://www.sudhanshumishra.in/</id><updated>2015-01-08T18:25:00+05:30</updated><entry><title>Two things: Dockerizing Applications and AWS’ on the house services</title><link href="http://www.sudhanshumishra.in/two-things-dockerizing-applications-and-aws-on-the-house-services" rel="alternate"></link><updated>2015-01-08T18:25:00+05:30</updated><author><name>Sudhanshu Mishra</name></author><id>tag:www.sudhanshumishra.in,2015-01-08:two-things-dockerizing-applications-and-aws-on-the-house-services</id><summary type="html">&lt;p&gt;Lately I migrated my app from DigitalOcean to &lt;span class="caps"&gt;AWS&lt;/span&gt; and encountered the
pain of setting up similar environment.(Documenting everything is very&amp;nbsp;important!)&lt;/p&gt;
&lt;p&gt;I heard long ago about &lt;a href="https://docker.io/"&gt;Docker&lt;/a&gt; but never bothered
to tinker with it. If you don&amp;#8217;t know, Docker is a platform for
developers and sysadmins to develop, ship, and run applications. Docker
lets you quickly assemble applications from components and eliminates
the friction that can come when shipping&amp;nbsp;code.&lt;/p&gt;
&lt;p&gt;&lt;img alt="docker" src="http://blog.docker.com/wp-content/uploads/2013/08/KuDr42X_ITXghJhSInDZekNEF0jLt3NeVxtRye3tqco.png" /&gt;&lt;/p&gt;
&lt;p&gt;It&amp;#8217;s just like a &lt;code&gt;git pull&lt;/code&gt; for your custom &lt;span class="caps"&gt;OS&lt;/span&gt;.
&lt;a href="https://docker.io/"&gt;https://docker.io&lt;/a&gt; manages repositories of docker
images, public and private. A docker image is just a set of layers where
layers are changes to its file system as results of commands. It uses
same commit system like git. Once you&amp;#8217;ve established an image you can
run your applications on it. Docker calls them containers. Each
container runs a single process. Even when containers run on same
environment, they are sandboxed to themselves. There&amp;#8217;s a &amp;#8216;sophisticated&amp;#8217;
way in which containers talk to each
other. &lt;a href="https://docs.docker.com/userguide/dockerizing"&gt;Here&amp;#8217;s&lt;/a&gt; a great
article on dockerizing your&amp;nbsp;applications.&lt;/p&gt;
&lt;p&gt;So yeah, I had to set up the same environment but just for once! Now I
can easily automate spawning new instances and adding them under
Amazon&amp;#8217;s &lt;span class="caps"&gt;ELB&lt;/span&gt;. It also made the development&amp;nbsp;easier.&lt;/p&gt;
&lt;p&gt;I&amp;#8217;m amazingly happy with Amazon&amp;#8217;s great products. Things like Elastic
&lt;span class="caps"&gt;IP&lt;/span&gt;, Elastic Load Balancer, Elastic Block Storage, S3, &lt;span class="caps"&gt;VPC&lt;/span&gt;, etc. can be
done with just few clicks. Setting up such infrastructure manually is a
nightmare. One thing which I miss here is MongoDB. Although there is
Amazon&amp;#8217;s own DynamoDB but I really don&amp;#8217;t want to learn another NoSQL &lt;span class="caps"&gt;DB&lt;/span&gt;.
I&amp;#8217;m using few &lt;span class="caps"&gt;EC2&lt;/span&gt; instances for&amp;nbsp;that.&lt;/p&gt;
&lt;p&gt;Cheers!&lt;/p&gt;</summary><category term="aws"></category><category term="cloud"></category><category term="docker"></category><category term="Server"></category></entry></feed>