<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>Shortlog</title><link href="http://www.sudhanshumishra.in/" rel="alternate"></link><link href="http://www.sudhanshumishra.in/feeds/electronics.category.atom.xml" rel="self"></link><id>http://www.sudhanshumishra.in/</id><updated>2015-01-16T19:36:00+05:30</updated><entry><title>Memory Error due to charge leak acceleration in DRAM</title><link href="http://www.sudhanshumishra.in/memory-error-due-to-charge-leak-acceleration-in-dram" rel="alternate"></link><updated>2015-01-16T19:36:00+05:30</updated><author><name>Sudhanshu Mishra</name></author><id>tag:www.sudhanshumishra.in,2015-01-16:memory-error-due-to-charge-leak-acceleration-in-dram</id><summary type="html">&lt;p&gt;DRAM comprises a two-dimensional array of DRAM cells, each of which
consists of a capacitor and an access-transistor. Depending on whether
its capacitor is fully charged or fully discharged, a cell is in either
the charged state or the discharged state, respectively. These two
states are used to represent a binary data value.
Dense packaging in DRAM leads to anomalies while performing continuous
read operations from same memory address which involves opening and
closing of the wordline. This anomaly will not be evident if the data is
read from an address after opening a wordline and not closing it. When
there are many activations to the same row, they force the wordline to
toggle on and off repeatedly. Such voltage fluctuations on a row’s
wordline have a disturbance effect on nearby rows, inducing some of
their cells to leak charge at an accelerated rate. If such a cell loses
too much charge before it is restored to its original value, it
experiences a disturbance error.This disturbance results mostly in
flipped bit value.Here's the assembly code which may induce errors when
executed on Intel/AMD machines.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;loop:
    mov X, %eax  ; Read from address X and save in register including
cache
    mov Y, %ebx  ; values in registers and cache
    clflush (X)  ; Clear data from cache
    clflush (Y)
    mfence       ; Make sure that data is fully flushed
    jmp loop
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;On the other hand, the following code will not induce errors because it
does not force continuous toggling of the wordline.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;loop:
    mov X, %eax  ; Read from address X and save in register including
cache
    clflush (X)  ; Clear data from cache
    mfence       ; Make sure that data is fully flushed
    jmp loop
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;These disturbances violate two invariants that memory should provide&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;A read access should not modify data at any address&lt;/li&gt;
&lt;li&gt;A write access should modify data only at the address being written to&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;This makes systems, using DRAM, vulnerable to data corruption.&lt;/p&gt;
&lt;p&gt;References:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Yoongu Kim, Ross Daly, Jeremie Kim, Chris Fallin, Ji Hye Lee,
Donghyuk Lee, Chris Wilkerson, Konrad Lai, Onur Mutlu et al. Flipping
Bits in Memory Without Accessing Them: An Experimental Study of DRAM
Disturbance Errors, 2014.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;A. J. van de Goor and I. Schanstra. Address and Data Scrambling:
Causes and Impact on Memory Tests. In DELTA, 2002&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;</summary><category term="Electronics"></category></entry><entry><title>BinPy: N Bit Ripple Counter</title><link href="http://www.sudhanshumishra.in/binpy-n-bit-ripple-counter" rel="alternate"></link><updated>2014-03-13T17:36:00+05:30</updated><author><name>Sudhanshu Mishra</name></author><id>tag:www.sudhanshumishra.in,2014-03-13:binpy-n-bit-ripple-counter</id><summary type="html">&lt;div dir="ltr" style="text-align: left;"&gt;
&lt;div dir="ltr" style="text-align: left;"&gt;
&lt;div class="separator" style="clear: both; text-align: center;"&gt;
[![](http://binpy.github.io/images/logo.png)](http://binpy.github.io/images/logo.png)

&lt;/div&gt;

&lt;p&gt;&lt;a href="http://binpy.github.io"&gt;BinPy&lt;/a&gt; is almost ready to create things. This
post focuses on building a ripple counter using it.  &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Theory&lt;/strong&gt;  &lt;/p&gt;
&lt;p&gt;A ripple counter is an asynchronous counter where only the first
flip-flop is clocked by an external clock. All subsequent flip-flops are
clocked by the output of the preceding flip-flop. Asynchronous counters
are also called ripple-counters because of the way the clock pulse
ripples it way through the flip-flops.  &lt;/p&gt;
&lt;p&gt;The MOD of the ripple counter or asynchronous counter is 2n if n
flip-flops are used. For a 4-bit counter, the range of the count is 0000
to 1111 (24-1). A counter may count up or count down or count up and
down depending on the input control. The count sequence usually repeats
itself. When counting up, the count sequence goes from 0000, 0001, 0010,
... 1110 , 1111 , 0000, 0001, ... etc. When counting down the count
sequence goes in the opposite manner: 1111, 1110, ... 0010, 0001, 0000,
1111, 1110, ... etc.  &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Implementation&lt;/strong&gt;  &lt;/p&gt;
&lt;p&gt;The following code is using BinPy's internal NBitRippleCounter.  &lt;/p&gt;
&lt;p&gt;Following is the output of the above code.  &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Under the hood&lt;/strong&gt;  &lt;/p&gt;
&lt;p&gt;When we are initializing the counter with specified number of bits, it
is actually creating those many T Flip Flops and connecting them in
order to get the result. The actual implementation is shown in the
following code.  &lt;/p&gt;
&lt;p&gt;Try connecting some wires with code, it's fun!&lt;br /&gt;
If you have some feedback or questions regarding this post, please add
comments. Cheers!   &lt;/p&gt;
&lt;p&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/p&gt;&lt;/p&gt;</summary><category term="BinPy"></category><category term="Circuit Design"></category><category term="Electronics"></category></entry></feed>